{"version":3,"file":"grademonitor.min.js","sources":["../src/grademonitor.js"],"sourcesContent":["/** @module grademonitor */\n\nimport Widget from 'lytix_helper/widget';\nimport Templates from 'core/templates';\nimport PercentRounder from 'lytix_helper/percent_rounder';\nimport {makeLoggingFunction} from 'lytix_logs/logs';\nimport {wwwroot} from 'core/config';\n\n// INTRODUCTION\n//\n// Most of the algorithms in this widget revolve around keeping track of scores, and calculating percentages.\n//\n// The more confusing parts consist of the conditions deciding what to do depending on the following questions:\n// - Is an item optional or mandatory?\n// - Is an item graded?\n// - Is there an average score for the item?\n// - Has an item been estimated by the student?\n//\n// Determining if the student’s goal is reachable, or if the student can even pass, is also slightly more complex.\n//\n// Also, there is a kind of buffering mechanism in place, designed to prevent frequent calls to the WS, batching them instead.\n//\n// Generally, the index of an item in the received JSON is used to identify it. The ID is only used for saving back to backend.\n\n\nconst WIDGET_ID = 'grademonitor';\n\nexport const init = (contextid, userid, courseid, locale) => {\n\n\n    const dataPromise = Widget.getData(\n        'local_lytix_lytix_grademonitor_grademonitor_get',\n        {contextid: contextid, courseid: courseid}\n    );\n\n    const stringsPromise = Widget.getStrings({\n        lytix_grademonitor: { // eslint-disable-line camelcase\n            differing: {\n                empty: 'goal_empty',\n                likely: 'goal_likely',\n                unlikely: 'goal_unlikely',\n                unachievable: 'goal_unachievable',\n                fail: 'goal_fail',\n                schemeUpdate: 'scheme_updated',\n            },\n            identical: [\n                'points',\n            ],\n        }\n    });\n\n    locale = Widget.convertLocale(locale);\n\n    Promise.all([stringsPromise, dataPromise])\n    .then(values => { // eslint-disable-line complexity\n        const\n            strings = values[0],\n            data = values[1],\n            items = data.Items,\n            itemIDs = items.IDs,\n            itemCount = itemIDs.length,\n            itemNames = items.Names,\n            maxScores = items.MaxScores,\n            scores = items?.Scores,\n            averages = items?.ClassAvgs,\n            estimations = items?.Estimations,\n            optionalIndexes = items?.OptionalIndexes,\n            checkedIndexes = items?.CheckedIndexes;\n\n        // These two should be constants after their initial calculation.\n        let\n            totalPoints = 0, // The sum of all points.\n            totalMandatoryPoints = 0; // The sum of all mandatory points (total minus optional).\n        {\n            // This block only calculates totalPoints and totalMandatoryPoints.\n            const optionalsIterator = optionalIndexes?.values();\n            let optionalIndex = optionalsIterator?.next().value;\n            for (let i = 0; i < itemCount; ++i) {\n                totalPoints += maxScores[i];\n                if (i != optionalIndex) {\n                    totalMandatoryPoints += maxScores[i];\n                } else {\n                    optionalIndex = optionalsIterator?.next().value;\n                }\n            }\n        }\n\n        const view = {\n            table: new Array(itemCount),\n            showAverage: data.ShowAverage,\n            gradeCompletion: 0,\n            currentGrade: 0,\n            selfEstimation: 0,\n            average: 0,\n            // Using a section in the template with an array literal of object literals is likely\n            // the most efficient way of dealing with this kind of repetition.\n            // The selected grade (the goal) is ‘marked’ in the condition below (by adding a property).\n            goalSelection: [\n                {grade: 1}, {grade: 2}, {grade: 3}, {grade: 4} // Skip 5, it would’nt make much sense.\n            ],\n        };\n        if (data.Goal) {\n            view.goalSelection[data.Goal - 1].selected = true;\n        }\n        if (data.LastSchemeUpdate) {\n            view.schemeNotification = strings.schemeUpdate + (new Date(data.LastSchemeUpdate * 1000)).toLocaleDateString(locale);\n        }\n\n        const\n            /**\n             * The grading scheme as received from backend.\n             * The first entry describes the percentage needed for a 4, the second for a 3, …\n             * @var {Array} scheme\n             */\n            scheme = data.Scheme,\n\n            /**\n             * Determine a grade from a percentage according to the {@link scheme} received from backend.\n             * @function gradeFromPercent\n             * @param {number} percent The percentage of achieved points for a certain items or sum of items.\n             * @return {number} 1–5\n             */\n            gradeFromPercent = percent => {\n                if (percent >= scheme[3]) {\n                    return 1;\n                }\n                let i = 0;\n                while (percent >= scheme[i]) {\n                    ++i;\n                }\n                return 5 - i;\n            },\n\n            /**\n             * Calculate the grade from points. This calculates the percentage and calls {@link gradeFromPercent}.\n             * @function gradeFromScore\n             * @param {number} score\n             * @param {number} maxScore\n             * @return {number} 1–5\n             */\n            gradeFromScore = (score, maxScore) => {\n                return gradeFromPercent(score / maxScore * 100);\n            };\n\n        const format = (new Intl.NumberFormat(locale, {maximumFractionDigits: 1})).format;\n\n\n        // For better readability the template data is created using two loops instead of a single large one.\n        // TODO: Profile this, maybe the performance difference is worth slightly less readable code.\n        // The first loop below generates the data for each item (== each table row).\n\n        const weightRounder = new PercentRounder();\n\n        // Iterators are not const because they will be reset (→ re-defined) later on, for the second large loop.\n        // The same goes for the corresponding values (optionalIndex, checkedIndex).\n        let\n            optionalsIterator = optionalIndexes?.values(),\n            checkedIterator = checkedIndexes?.values(),\n            optionalIndex = optionalsIterator?.next().value,\n            checkedIndex = checkedIterator?.next().value;\n\n        for (let i = 0; i < itemCount; ++i) {\n            const\n                maxScore = maxScores[i],\n                score = scores?.[i],\n                average = averages?.[i],\n                estimation = estimations?.[i],\n                assessed = score !== undefined && score >= 0,\n                weight = maxScore / totalMandatoryPoints * 100,\n                optional = i === optionalIndex,\n                checked = i === checkedIndex;\n\n            const item = view.table[i] = {\n                itemName: itemNames[i],\n                index: i,\n                assessed: assessed,\n                checked: assessed || checked,\n                optional: optional,\n                value: 0,\n            };\n\n            if (checked) {\n                checkedIndex = checkedIterator?.next().value;\n            }\n\n            if (average !== undefined && average >= 0) {\n                item.average = optional ?\n                    format(average) + strings.points : format(gradeFromScore(average, maxScore));\n            }\n\n            if (optional) {\n                optionalIndex = optionalsIterator?.next().value;\n\n                item.weight = Math.round(weight);\n\n                if (estimation !== undefined && estimation >= 0) {\n                    item.estimation = format(maxScore / 100 * estimation);\n                    item.value = estimation;\n                }\n                if (assessed) {\n                    item.result = format(score);\n                    item.value = score / maxScore * 100;\n                }\n            } else {\n                item.weight = weightRounder.round(weight);\n                item.estimation = estimation !== undefined && estimation >= 0 ? gradeFromPercent(estimation) : false;\n\n                if (assessed) {\n                    view.gradeCompletion += weight;\n\n                    const percent = item.value = score / maxScore * 100;\n                    item.result = format(gradeFromPercent(percent));\n                } else if (estimation !== undefined && estimation >= 0) {\n                    item.value = estimation;\n                    item.estimation = gradeFromPercent(estimation);\n                }\n            }\n        }\n\n        view.gradeCompletion = format(view.gradeCompletion);\n\n\n        // Here we start preparing the second big loop, which calculates the values displayed below the table:\n        // - course completion (how much has been graded)\n        // - current grade\n        // - overall class average\n        // - the self-estimated final grade\n\n        // TODO: Maybe unpack this into separate variables for better minification?\n        // This keeps track of the sums of the total number of points achievable for …\n        const accumulatedMax = {\n            score: 0, // … all graded items,\n            estimate: 0, // … all estimated items,  ← This is a superset of scores.\n            average: 0, // … all items that have a class average.\n        };\n\n        // These keep track of the total scores (→ in points, not percent); they are essential for later grade calculation.\n        let\n            accumulatedScore = 0, // The actual score of the user.\n            accumulatedOptionalScore = 0, // The score of optional items.\n            accumulatedAverage = 0, // The sum of the course average.\n            accumulatedEstimation = 0, // The estimated score.\n            accumulatedOptionalEstimation = 0, // The estimated score of optional items.\n            remainingPoints = totalPoints, // The sum of points of all remaining (ungraded) items.\n            remainingMandatoryPoints = totalMandatoryPoints; // The sum of points of all remaining mandatory items.\n\n        // Use item indexes as property names, each referring to an estimate (percentage).\n        const indexToEstimate = {};\n\n        // Reset the iterators that had first been declared for the first big loop.\n        optionalsIterator = optionalIndexes?.values();\n        optionalIndex = optionalsIterator?.next().value;\n        checkedIterator = checkedIndexes?.values();\n        checkedIndex = checkedIterator?.next().value;\n\n        for (let i = 0; i < itemCount; ++i) {\n            const\n                maxScore = maxScores[i],\n                score = scores?.[i],\n                average = averages?.[i],\n                optional = i === optionalIndex;\n\n            if (optional) {\n                optionalIndex = optionalsIterator.next().value;\n            }\n\n            if (average !== undefined && average >= 0) {\n                accumulatedAverage += average;\n                if (!optional) {\n                    accumulatedMax.average += maxScore;\n                }\n            }\n\n            if (score !== undefined && score >= 0) {\n                accumulatedScore += score;\n                accumulatedEstimation += score;\n                if (optional) {\n                    accumulatedOptionalScore += score;\n                    accumulatedOptionalEstimation += score;\n                } else {\n                    accumulatedMax.score += maxScore;\n                    accumulatedMax.estimate += maxScore;\n                    remainingMandatoryPoints -= maxScore;\n                }\n                remainingPoints -= maxScore;\n            } else {\n                const\n                    estimation = estimations?.[i],\n                    estimated = estimation !== undefined && estimation >= 0;\n                if (estimated) {\n                    indexToEstimate[i] = estimation;\n                }\n                if (i === checkedIndex) {\n                    checkedIndex = checkedIterator.next().value;\n                    // This check might be redundant: An item should not be able to be checked but not have an estimate.\n                    if (estimated) {\n                        const estimatedScore = maxScore / 100 * estimation;\n                        accumulatedEstimation += estimatedScore;\n                        if (optional) {\n                            accumulatedOptionalEstimation += estimatedScore;\n                        } else {\n                            accumulatedMax.estimate += maxScore;\n                        }\n                    }\n                }\n            }\n        }\n\n        view.average = averages !== undefined && averages.length > 0 ?\n            format(gradeFromScore(accumulatedAverage, accumulatedMax.average)) : '–';\n\n        // Has any item been graded?\n        const anyScores = scores !== undefined && scores.length > 0;\n\n        /**\n        /* The effective grade only considers optional items if enough mandatory items are positive.\n         * @function getEffectiveGrade\n         * @param {number} accumulatedPoints How many points are considered?\n         * @param {number} accumulatedOptionalPoints How many of the considered points are optional?\n         * @param {number} accumulatedMaxPoints The total possible score of considered items.\n         * @return {number} The effective grade (1–5).\n         */\n        const getEffectiveGrade = (accumulatedPoints, accumulatedOptionalPoints, accumulatedMaxPoints) => {\n            // The grade without considering optional items.\n            const mandatoryGrade = gradeFromScore(accumulatedPoints - accumulatedOptionalPoints, accumulatedMaxPoints);\n            return mandatoryGrade < 5 ? gradeFromScore(accumulatedPoints, accumulatedMaxPoints) : mandatoryGrade;\n        };\n\n        view.currentGrade = anyScores ?\n            format(getEffectiveGrade(accumulatedScore, accumulatedOptionalScore, accumulatedMax.score)) : '–';\n\n        let currentEstimatedGrade;\n\n        if (checkedIndexes?.length > 0 && estimations?.length > 0 || anyScores) {\n            const effectiveEstimation =\n                getEffectiveGrade(accumulatedEstimation, accumulatedOptionalEstimation, accumulatedMax.estimate);\n            view.selfEstimation = format(currentEstimatedGrade = effectiveEstimation);\n        } else {\n            view.selfEstimation = '–';\n        }\n\n\n        // Keeps track of the current CSS class of the goal status message.\n        let currentGoalClass = '';\n\n        let\n            bestPossibleGrade,\n            bestPossibleMandatoryGrade =\n                gradeFromScore(accumulatedScore - accumulatedOptionalScore + remainingMandatoryPoints, totalMandatoryPoints);\n        if (bestPossibleMandatoryGrade < 5) {\n            bestPossibleGrade = gradeFromScore(accumulatedScore + remainingPoints, totalMandatoryPoints);\n        } else {\n            bestPossibleGrade = bestPossibleMandatoryGrade;\n        }\n\n        /**\n         * Determines if the given goal is achievable or if the student can pass at all;\n         * returns an object containing the message and the CSS class for the goal status banner.\n         * @function getGoalStatus\n         * @param {number} goal The desired grade (1–4).\n         * @return {Object} An object with the properties ‘message’ and ‘class’.\n         */\n        const getGoalStatus = goal => {\n            if (goal === 0) {\n                return {\n                    message: strings.empty,\n                    'class': 'alert-warning',\n                };\n            } else if (goal >= bestPossibleGrade) {\n                if (currentEstimatedGrade !== undefined && goal >= currentEstimatedGrade) {\n                    return {\n                        message: strings.likely,\n                        'class': 'alert-success',\n                    };\n                }\n                return {\n                    message: strings.unlikely,\n                    'class': 'alert-warning',\n                };\n            } else if (bestPossibleGrade < 5) {\n                return {\n                    message: strings.unachievable,\n                    'class': 'alert-danger',\n                };\n            }\n            return {\n                message: strings.fail,\n                'class': 'alert-danger',\n            };\n        };\n        {\n            const status = getGoalStatus(data.Goal ?? 0);\n            view.goalStatus = status.message;\n            view.goalClass = currentGoalClass = status.class;\n        }\n\n\n        // Finally render the template.\n\n        return Templates.render('lytix_grademonitor/grademonitor', view)\n        .then(html => {\n            Widget.getContentContainer(WIDGET_ID).insertAdjacentHTML('beforeend', html);\n            const\n                widget = document.getElementById('grademonitor'),\n                finalEstimationLabel = widget.querySelector('.final-estimation'),\n                checkboxes = widget.querySelectorAll('td input[type=checkbox]'),\n                itemEstimationLabels = widget.querySelectorAll('td.estimation');\n\n            const\n                // This is used to track if data concerning individual tasks has changed.\n                // Global changes (showAverage, goal, schemeUpdateSeen) do not need any additional tracking,\n                // the presence of their respective property in ’updated’ is sufficient to indicates changes.\n                hasChanged = {\n                    estimations: false,\n                    checked: false,\n                },\n                // This stores all values that have been updated since last saving to backend.\n                updated = {\n                    estimations: {},\n                    checked: {},\n                    // The other keys (showAverage, goal, schemeUpdateSeen) are simple values, they will be created on the fly.\n                };\n\n            /** This stores logging entries until they are sent to backend, afterwards it will be replaced with an empty array. */\n            let logs = [];\n\n            /**\n             * Save data from {@link updated} and loggin entries from {@link logs} back to backend.\n             * This is usually called by {@link queueUpdate} or when the page is left (via EventListener).\n             * @function saveData\n             */\n            const\n                log = makeLoggingFunction(userid, courseid, contextid, 'grademonitor'),\n                complexKeys = ['estimations', 'checked'],\n                simpleKeys = data.LastSchemeUpdate ? ['goal', 'showAverage', 'schemeUpdateSeen'] : ['goal', 'showAverage'],\n                beaconUrl = wwwroot + '/local/lytix/modules/grademonitor/endpoint/grademonitor_update.php',\n                saveData = () => {\n                    if (timeoutId === null) {\n                        return;\n                    }\n                    const changes = {};\n                    // We could not use a for-of-loop because Babel would mess it up.\n                    for (let i = 0; i < 2; ++i) {\n                        const key = complexKeys[i];\n                        if (hasChanged[key]) {\n                            changes[key] = updated[key];\n                            updated[key] = {};\n                            hasChanged[key] = false;\n                        }\n                    }\n                    // … same here.\n                    for (let i = simpleKeys.length - 1; i >= 0; --i) {\n                        const key = simpleKeys[i];\n                        if (updated[key] !== undefined) {\n                            changes[key] = updated[key];\n                            updated[key] = undefined;\n                        }\n                    }\n\n                    const logCount = logs.length;\n                    for (let i = 0; i < logCount; ++i) {\n                        const l = logs[i];\n                        log(l[0], l[1], l[2], l[3]);\n                    }\n                    logs = [];\n\n                    // Use sendBeacon as it is guaranteed to be completed, even after the user has left the page.\n                    navigator.sendBeacon(\n                        beaconUrl,\n                        JSON.stringify({contextid, courseid, changes})\n                    );\n\n                    timeoutId = null;\n                };\n\n            let timeoutId = null;\n            /**\n             * This starts or resets a timer to call {@link saveData}.\n             * @function queueUpdate\n             */\n            const queueUpdate = () => {\n                clearTimeout(timeoutId);\n                timeoutId = setTimeout(saveData, 120000); // Wait 2 minutes.\n            };\n\n\n            const optionalIndexeSet = new Set(optionalIndexes);\n\n            // This is the sum of total scores of all checked mandatory tasks.\n            let accumulatedMaxScore = accumulatedMax.estimate;\n\n            // This is the central event listener, that deals with all parameter changes thtat affect the estimation.\n            // An important detail: When the range input is changed, the item is automatically checked.\n            widget.querySelector('table').addEventListener('input', event => {\n                const target = event.target;\n\n                // First, find the affected row element.\n                let row = target;\n                do {\n                    row = row.parentElement;\n                } while (row.dataset.index == undefined);\n\n                const\n                    itemIndex = parseInt(row.dataset.index),\n                    itemId = itemIDs[itemIndex],\n                    maxScore = maxScores[itemIndex],\n                    currentEstimation = indexToEstimate[itemIndex] ?? 0,\n                    optional = optionalIndexeSet.has(itemIndex),\n                    checkbox = checkboxes[itemIndex],\n                    isCheckboxEvent = target.type == 'checkbox';\n\n                let checkboxChanged = isCheckboxEvent;\n\n                // The estimation (range input) changes, but the item was previously unchecked.\n                if (!isCheckboxEvent && !checkbox.checked) {\n                    checkboxChanged = checkbox.checked = true;\n                }\n\n                if (checkboxChanged) {\n                    hasChanged.checked = true;\n                    const sign = (updated.checked[itemId] = checkbox.checked) && 1 || -1;\n                    if (!optional) {\n                        accumulatedMaxScore += maxScore * sign;\n                    }\n                    const scoreDelta = maxScore / 100 * currentEstimation * sign;\n                    accumulatedEstimation += scoreDelta;\n\n                    if (checkbox.checked) {\n                        row.classList.remove('unchecked');\n                    } else {\n                        row.classList.add('unchecked');\n                    }\n                    logs.push([checkbox.checked ? 'INCLUDE' : 'EXCLUDE', 'ITEM', null, itemId]);\n                }\n\n                // The estimation (range input) changes.\n                if (!isCheckboxEvent) {\n                    hasChanged.estimations = true;\n                    const\n                        newEstimation = indexToEstimate[itemIndex] = updated.estimations[itemId] = parseInt(target.value),\n                        scoreDelta = maxScore / 100 * (newEstimation - currentEstimation);\n                    accumulatedEstimation += scoreDelta;\n\n                    if (optional) {\n                        itemEstimationLabels[itemIndex].innerText =\n                            format(maxScore / 100 * newEstimation) + strings.points;\n                        accumulatedOptionalEstimation += scoreDelta;\n                    } else {\n                        itemEstimationLabels[itemIndex].innerText = format(gradeFromPercent(newEstimation));\n                    }\n                    logs.push(['CHANGE', 'ESTIMATION', newEstimation, itemId]);\n                }\n\n                const previousEstimatedGrade = currentEstimatedGrade;\n\n                // See if there even are any (mandatory) items checked.\n                if (accumulatedMaxScore > 0) {\n                    const effectiveEstimation =\n                        getEffectiveGrade(accumulatedEstimation, accumulatedOptionalEstimation, accumulatedMaxScore);\n                    finalEstimationLabel.innerText = format(effectiveEstimation);\n                    currentEstimatedGrade = effectiveEstimation;\n                } else {\n                    finalEstimationLabel.innerText = '–';\n                    currentEstimatedGrade = undefined;\n                }\n\n                if (currentGoal && currentEstimatedGrade !== previousEstimatedGrade) {\n                    updateGoalStatus();\n                }\n\n                queueUpdate();\n            });\n\n\n            // In order to hide the class average column AND control column width with <colgroup> we have to get tricky.\n            // The averageCol is inserted after nameCol, which is why we need references to both.\n            // We do not use ‘visibility: collapse’ because it wastes space and causes layout problems.\n\n            const\n                classAverages = widget.querySelectorAll('.class-average'),\n                nameCol = document.querySelector('col.name'),\n                averageCol = data.ShowAverage ? document.querySelector('col.average') : document.createElement('col');\n            if (!data.ShowAverage) {\n                averageCol.classList.add('average');\n            }\n            document.getElementById('show-average-control').addEventListener('change', event => {\n                for (let i = classAverages.length - 1; i >= 0; --i) {\n                    classAverages[i].classList.toggle('d-none');\n                }\n                if ((updated.showAverage = data.ShowAverage = !data.ShowAverage)) {\n                    nameCol.insertAdjacentElement('afterend', averageCol);\n                } else {\n                    averageCol.parentElement.removeChild(averageCol);\n                }\n                logs.push([event.target.checked ? 'SHOW' : 'HIDE', 'COURSE AVERAGE']);\n                queueUpdate();\n            });\n\n\n            let currentGoal = data.Goal;\n            const\n                goalElement = document.getElementById('grade-goal'),\n                goalStatus = document.getElementById('goal-status'),\n                updateGoalStatus = (goal = currentGoal) => {\n                    const status = getGoalStatus(goal);\n\n                    goalStatus.innerText = status.message;\n\n                    goalElement.classList.remove(currentGoalClass);\n                    goalElement.classList.add(currentGoalClass = status.class);\n                };\n            goalElement.addEventListener('change', event => {\n                updateGoalStatus(currentGoal = updated.goal = parseInt(event.target.value));\n                logs.push(['CHANGE', 'GOAL', currentGoal]);\n                queueUpdate();\n            });\n\n            document.getElementById('dismiss-scheme-update')?.addEventListener('click', event => {\n                updated.schemeUpdateSeen = true;\n                queueUpdate();\n                event.target.parentElement.remove();\n            }, {once: true});\n\n            window.addEventListener('beforeunload', saveData);\n            return;\n        });\n    })\n    .finally(() => {\n        document.getElementById(WIDGET_ID).classList.remove('loading');\n    })\n    .catch(error => Widget.handleError(error, WIDGET_ID));\n};\n"],"names":["contextid","userid","courseid","locale","dataPromise","Widget","getData","stringsPromise","getStrings","lytix_grademonitor","differing","empty","likely","unlikely","unachievable","fail","schemeUpdate","identical","convertLocale","Promise","all","then","values","strings","data","items","Items","itemIDs","IDs","itemCount","length","itemNames","Names","maxScores","MaxScores","scores","Scores","averages","ClassAvgs","estimations","Estimations","optionalIndexes","OptionalIndexes","checkedIndexes","CheckedIndexes","totalPoints","totalMandatoryPoints","optionalsIterator","optionalIndex","next","value","i","view","table","Array","showAverage","ShowAverage","gradeCompletion","currentGrade","selfEstimation","average","goalSelection","grade","Goal","selected","LastSchemeUpdate","schemeNotification","Date","toLocaleDateString","scheme","Scheme","gradeFromPercent","percent","gradeFromScore","score","maxScore","format","Intl","NumberFormat","maximumFractionDigits","weightRounder","PercentRounder","checkedIterator","_optionalsIterator","checkedIndex","_checkedIterator","estimation","assessed","undefined","weight","optional","checked","item","itemName","index","_checkedIterator2","points","_optionalsIterator2","Math","round","result","accumulatedMax","estimate","accumulatedScore","accumulatedOptionalScore","accumulatedAverage","accumulatedEstimation","accumulatedOptionalEstimation","remainingPoints","remainingMandatoryPoints","indexToEstimate","_optionalsIterator3","_checkedIterator3","estimated","estimatedScore","anyScores","getEffectiveGrade","accumulatedPoints","accumulatedOptionalPoints","accumulatedMaxPoints","mandatoryGrade","currentEstimatedGrade","effectiveEstimation","bestPossibleGrade","currentGoalClass","bestPossibleMandatoryGrade","getGoalStatus","goal","message","status","goalStatus","goalClass","class","Templates","render","html","getContentContainer","insertAdjacentHTML","widget","document","getElementById","finalEstimationLabel","querySelector","checkboxes","querySelectorAll","itemEstimationLabels","hasChanged","updated","logs","log","complexKeys","simpleKeys","beaconUrl","wwwroot","saveData","timeoutId","changes","key","logCount","l","navigator","sendBeacon","JSON","stringify","queueUpdate","clearTimeout","setTimeout","optionalIndexeSet","Set","accumulatedMaxScore","addEventListener","event","target","row","parentElement","dataset","itemIndex","parseInt","itemId","currentEstimation","has","checkbox","isCheckboxEvent","type","checkboxChanged","sign","classList","remove","add","push","newEstimation","scoreDelta","innerText","previousEstimatedGrade","currentGoal","updateGoalStatus","classAverages","nameCol","averageCol","createElement","toggle","insertAdjacentElement","removeChild","goalElement","schemeUpdateSeen","once","window","finally","catch","error","handleError"],"mappings":"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"}